def generate_byte_array(array_size: int, *args) -> bytearray:
    """Generates a bytearray filled with data extracted from arguments within specified bit ranges.

    Args:
        array_size (int): The size of the bytearray to be generated.
        *args: Variable length argument list. Each argument should be a tuple containing:
            - The data value (int).
            - The starting bit index (inclusive) of the data within the generated bytearray.
            - The ending bit index (inclusive) of the data within the generated bytearray.

    Returns:
        bytearray: The generated bytearray filled with data extracted from arguments within specified bit ranges.

    This static method generates a bytearray with the specified size and fills it with data extracted
    from the provided arguments, where each argument represents a piece of data to be inserted
    into the bytearray. The data is inserted into the specified bit range within the bytearray.
    """
    byte_array = bytearray(array_size)

    for arg in args:
        data = int(arg[0])
        start_bit = int(arg[1])
        end_bit = int(arg[2])
        # Calculate start_byte, start_bit_offset, end_byte, end_bit_offset
        start_byte, start_bit_offset = divmod(start_bit, 8)
        end_byte, end_bit_offset = divmod(end_bit, 8)
        for byte_offset in range(start_byte, end_byte + 1):
            byte_value = 0

            # Iterate through each bit in the byte
            for bit_offset in range(8):
                # Calculate the bit index in the byte array
                current_bit = byte_offset * 8 + bit_offset

                # Check if the current bit falls within the specified range
                if start_bit <= current_bit <= end_bit:
                    # Extract the bit value from the data and set it in the byte_value
                    bit_value = (data >> bit_offset) & 1
                    byte_value |= bit_value << bit_offset

            # Store the byte_value in the byte array
            byte_array[byte_offset] = byte_value

    return byte_array


def print_byte_array(byte_array):
    hex_string = ' '.join(format(byte, '02x') for byte in byte_array)
    ascii_string = ''.join(chr(byte) if 32 <= byte <= 126 else '.' for byte in byte_array)

    for i in range(0, len(byte_array), 16):
        chunk_hex = hex_string[i:i + 32]
        chunk_ascii = ascii_string[i:i + 16]
        print(f"{chunk_hex.ljust(48)} {chunk_ascii}")




brake_en_ctrl = (1, 0, 0)
aeb_en_ctrl = (1, 1, 1)

brake_dec_upper_byte = (((int(1.0 / 0.01) >> 8) & 0xFF), 8, 15)
brake_dec_lower_byte = ((int(1.0 / 0.01) & 0b11), 22, 23)
print(1.0 / 0.01)
print(f'brake_dec_upper_byte ::{brake_dec_upper_byte[0]}')
print(f'brake_dec_lower_byte ::{brake_dec_lower_byte[0]}')

brake_pedal_target_upper_byte = (((int(10.0 / 0.1) >> 8) & 0xFF), 24, 31)
brake_pedal_target_lower_byte = ((int(10.0 / 0.1) & 0xFF), 32, 39)

print(f'brake_pedal_target_upper_byte :: {brake_pedal_target_upper_byte[0]}')
print(f'brake_pedal_target_lower_byte :: {brake_pedal_target_lower_byte[0]}')

print_byte_array(generate_byte_array(8, brake_en_ctrl, aeb_en_ctrl, brake_dec_upper_byte, brake_dec_lower_byte,
                                   brake_pedal_target_upper_byte, brake_pedal_target_lower_byte))