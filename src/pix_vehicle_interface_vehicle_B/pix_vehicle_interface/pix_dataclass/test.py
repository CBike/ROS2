def generate_byte_array(array_size: int, *args, checksum: bool = False) -> bytearray:
    """Generates a bytearray filled with data extracted from arguments within specified bit ranges.

    Args:
        checksum: checksum option
        array_size (int): The size of the bytearray to be generated.
        *args: Variable length argument list. Each argument should be a tuple containing:
            - The data value (int).
            - The starting bit index (inclusive) of the data within the generated bytearray.
            - The ending bit index (inclusive) of the data within the generated bytearray.

    Returns:
        bytearray: The generated bytearray filled with data extracted from arguments within specified bit ranges.

    This static method generates a bytearray with the specified size and fills it with data extracted
    from the provided arguments, where each argument represents a piece of data to be inserted
    into the bytearray. The data is inserted into the specified bit range within the bytearray.
    """
    byte_array = bytearray(array_size)

    for arg in args:
        data = int(arg[0])
        start_bit = int(arg[1])
        end_bit = int(arg[2])

        # Calculate start_byte, start_bit_offset, end_byte, end_bit_offset
        start_byte, start_bit_offset = divmod(start_bit, 8)
        end_byte, end_bit_offset = divmod(end_bit, 8)

        for byte_offset in range(start_byte, end_byte + 1):
            byte_value = 0
            # Iterate through each bit in the byte
            for bit_offset in range(8):
                # Calculate the bit index in the byte array
                current_bit = byte_offset * 8 + bit_offset

                # Check if the current bit falls within the specified range
                if start_bit <= current_bit <= end_bit:
                    # Extract the bit value from the data and set it in the byte_value
                    bit_value = (data >> (current_bit - start_bit)) & 1
                    byte_value |= bit_value << bit_offset

            # Store the byte_value in the byte array
            byte_array[byte_offset] |= byte_value

    if checksum:
        byte_array[7] = (byte_array[0] ^ byte_array[1] ^ byte_array[2] ^ byte_array[3] ^
                         byte_array[4] ^ byte_array[5] ^ byte_array[6])

    return byte_array

def print_byte_array(byte_array):
    hex_string = ' '.join(format(byte, '02x') for byte in byte_array[::-1])
    ascii_string = ''.join(chr(byte) if 32 <= byte <= 126 else '.' for byte in byte_array[::-1])

    for i in range(0, len(byte_array), 16):
        chunk_hex = hex_string[i*3:i*3 + 32*3].strip()
        chunk_ascii = ascii_string[i:i + 16]
        print(f"{chunk_hex.ljust(48)} {chunk_ascii}")



if __name__ == '__main__':
    vehicle_brake_control_enable = 0
    vehicle_brake_light_control = 0
    vehicle_brake_control = 0
    parking_control = 2
    cycle_count = 15
    vehicle_brake_control_enable = (vehicle_brake_control_enable, 0, 0)
    vehicle_brake_light_control = (vehicle_brake_light_control, 1, 1)

    vehicle_brake_control_lower = ((int(vehicle_brake_control / 0.1) << 2) & 0xFF, 8, 15)
    vehicle_brake_control_upper = (int(vehicle_brake_control / 0.1) & 0b11, 16, 17)

    parking_control = (parking_control, 24, 25)
    cycle_count = (cycle_count, 48, 51)

    ret = generate_byte_array(8, vehicle_brake_control_enable,
                                  vehicle_brake_light_control,
                                  vehicle_brake_control_lower,
                                  vehicle_brake_control_upper,
                                  parking_control,
                                  cycle_count, checksum=True)
    print(f'brake control: {ret}')

